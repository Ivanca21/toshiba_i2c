/**
 * @file main.c
 * @brief Main function for TOSHIBA_uart_polling application.
 */

/**
 * Any initialization code needed for MCU to function properly.
 * Do not remove this line or clock might not be set correctly.
 */
#ifdef PREINIT_SUPPORTED
#include "preinit.h"
#endif



#include "mcu.h"
#include <stdbool.h>
#include <stdint.h>


typedef struct
{
  volatile uint32_t SWRST;             /*!< UART Software Reset Register                 */
  volatile uint32_t CR0;               /*!< UART Control Register 0                      */
  volatile uint32_t CR1;               /*!< UART Control Register 1                      */
  volatile uint32_t CLK;               /*!< UART Clock Control Register                  */
  volatile uint32_t BRD;               /*!< UART Baud Rate Register                      */
  volatile uint32_t TRANS;             /*!< UART Transfer Enable Register                */
  volatile uint32_t DR;                /*!< UART Data Register                           */
  volatile uint32_t SR;                /*!< UART Status Register                         */
  volatile  uint32_t FIFOCLR;           /*!< UART FIFO Clear Register                     */
  volatile uint32_t ERR;               /*!< UART Error Register                          */
} UART_TypeDef;


UART_TypeDef* uart_registers;

#define PERIF_BASE             0x40000000UL
#define UART_CH3_TYPE2         0x00CEC00UL


/*=====================================================================BIT MASKS=====================================================================================*/

#define BIT0                        (1U << 0)      
#define BIT1                        (1U << 1)      
#define BIT2                        (1U << 2)      
#define BIT3                        (1U << 3)      
#define BIT4                        (1U << 4)
#define BIT0                        (1U << 0)      
#define BIT1                        (1U << 1)       
#define BIT2                        (1U << 2)      
#define BIT5                        (1U << 5)     
#define BIT6                        (1U << 6)    
#define BIT7                        (1U << 7)  

/*============== SWRST ==================*/
#define SWRST_pos              (0)
#define SWRST_mask             (0x00000003 << SWRST_pos)

#define set_SWRST(val)         (((uint32_t)val << SWRST_pos) & SWRST_mask)

static inline void set_SWRST_bits(UART_TypeDef* uart_registers, uint8_t bits){
    uint32_t reg = uart_registers->SWRST & ~SWRST_mask;
    reg |= set_SWRST(bits);
    uart_registers->SWRST = reg;
}

#define SWRSTF_mask            (0x00000001 << 7)

/*============== CR0 ==================*/
#define CR0_SM_pos            (0)
#define CR0_SM_mask           (0x00000003 << CR0_SM_pos)

#define set_SM(val)         (((uint32_t)val << CR0_SM_pos) & CR0_SM_mask)

static inline void set_data_length(UART_TypeDef* uart_registers, uint8_t bits){
    uint32_t reg = uart_registers->CR0 & ~CR0_SM_mask;
    reg |= set_SM(bits);
    uart_registers->CR0 = reg;
}

/*============== SR ==================*/
#define SR_SUE_mask            (0x00000001 << 31)
#define SR_TXRUN_mask          (0x00000001 << 15)
#define SR_TXEND_mask          (0x00000001 << 14)
#define SR_TLVL_mask           (0x0000000F << 8)
#define SR_RXRUN_mask          (0x00000001 << 7)
#define SR_RXEND_mask          (0x00000001 << 6)
#define SR_RLVL_mask           (0x0000000F << 0)







/*============== CR1 ==================*/
#define CR1_INTTXWE_mask       (0x00000001 << 6)
#define CR1_INTRXWE_mask       (0x00000001 << 4)

/*============== BRD ==================*/
#define BRD_KEN_mask           (0x00000001 << 23)

#define BRK_pos                (16)
#define BRK_mask               (0x0000003F << BRK_pos)

#define set_BRK(val)         (((uint32_t)val << BRK_pos) & BRK_mask)

static inline void set_BRK_bits(UART_TypeDef* uart_registers, uint8_t bits){
    uint32_t reg = uart_registers->BRD & ~BRK_mask;
    reg |= set_BRK(bits);
    uart_registers->BRD = reg;
}


#define BRN_pos                (0)
#define BRN_mask               (0x0000FFFF << BRN_pos)

#define set_BRN(val)         (((uint32_t)val << BRN_pos) & BRN_mask)

static inline void set_BRN_bits(UART_TypeDef* uart_registers, uint16_t bits){
    uint32_t reg = uart_registers->BRD & ~BRN_mask;
    reg |= set_BRN(bits);
    uart_registers->BRD = reg;
}

/*============== TRANS ==================*/
#define TRANS_BK_mask             (0x00000001 << 3)
#define TRANS_TXE_mask            (0x00000001 << 1)
#define TRANS_RXE_mask            (0x00000001 << 0)
#define TRANS_TXTRG_mask          (0x00000001 << 2)


/*============== FIFOCLR ==================*/
#define FIFOCLR_TFCLR_mask        (0x00000001 << 1)
#define FIFOCLR_RFCLR_mask        (0x00000001 << 0)




static void uart_init();

static void send_data(uint8_t data);

uint32_t fsys_mhz(void);



int main(void)
{
    /* Do not remove this line or clock might not be set correctly. */
    #ifdef PREINIT_SUPPORTED
    preinit();
    #endif

    

    uart_registers = (UART_TypeDef *)(PERIF_BASE + UART_CH3_TYPE2);

    
    uart_init();

    uint8_t data = 9;

    send_data(data);

     uint32_t test = fsys_mhz();
    

    /* Replace with your application code */
    while (1)
    {
    }

    return 0;
}


static void uart_init(){
    /*clock i portovi:*/
    TSB_CG_FSYSMENA_IPMENA05 = 1;  /* port F */
    TSB_CG_FSYSMENA_IPMENA24 = 1;  /* uart ch3 */

    /*
    MIKROBUS3 and MIKROBUS4:
    pf6 - TX
    PF7 - RX
    */

    TSB_PF->CR |= BIT6;
    TSB_PF->FR1 |= BIT6;
    TSB_PF->IE &= ~BIT6;

    TSB_PF->CR &= ~BIT7;
    TSB_PF->FR1 |= BIT7;
    TSB_PF->IE |= BIT7;
    
    /*
    "The sequence of the write of "10" and the next write of "01" generates the software reset."
     this initialises : TRANS, DR, SR, ERR and read_write poiners of tx/rx FIFOs.
     when read, "00" is returned
     thsi will set SR_SUO = 0 which enables seetings
    */
    set_SWRST_bits(uart_registers, 2);
    set_SWRST_bits(uart_registers, 1);

    /*If the software reset is asserted, the next operation should be done after <SWRSTF> is checked to be "0". -> page 25
     hardware will clear this flag itself when the initialization is done
    */
    while((uart_registers->SWRST & SWRSTF_mask) != 0) {}



    /*
     data format: LSB first, no data inversion, 1 stop bit, parity disabled, data length = 8 bits 
     output is TXDA pin 
     */
    set_data_length(uart_registers, 1);
  

    /*
    CR1 nista ne treba menjati
    INTRXWE i INTRXFE ne must not be both set to 1 at the same time -> page 14
    */
    
    /* PRESCALER : divide ratio = 1/1 by default */
    /* baud rate = 9600 */
    uart_registers->BRD |= BRD_KEN_mask;
    set_BRK_bits(uart_registers, 0x15);
    set_BRN_bits(uart_registers, 0x441);
    
    /* this initializes write/read pointers of rx-tx FIFOs */
    uart_registers->FIFOCLR |= FIFOCLR_TFCLR_mask | FIFOCLR_RFCLR_mask;

    /*==== SR =====*/
    /* when one fram is sent/recieved TXEND/RXEND is always set to 1, but if INTRXWE/INTTXWE is set to 1 then int will be generated */

     /* 
     when data transmition is enabled,data in FIFO is moved to SHIFT reg(then goes to TXDA/B) -> page 14
     once enabled,if data exists in DR,transmition starts,otherwise it starts once its written to DR -> page 19
     normal transmition => TXTRG should be set to 0.
     transmition coninues until all data in the trensmit FIFO are transmitted
     when TLVL increments => SR_TXRUN is set to 1,when transmit is done TXRUN clears which sets TXEND.
     when TXE is cleared during transmittion, it stop after transmitting current frame -> DATA in FIFO is maintained.
     re-enabling transmission -> set TXE = 1 after checking TXRUN = 0
     */
     uart_registers->TRANS &= ~TRANS_TXTRG_mask;
     uart_registers->TRANS |=  TRANS_TXE_mask;   /* after setting TXE/RXE => SR_SUE is set to 1 -> setting disabled*/
}


static void send_data(uint8_t data){

    /* clear TXEND */
    //uart_registers->SR |= SR_TXEND_mask;
    
    uart_registers->DR = data;

    while(!(uart_registers->SR & SR_TXEND_mask)) {}
    uart_registers->SR |= SR_TXEND_mask;
}



static uint8_t read_data(){
       /* reg DR should not be read when the recieve FIFO is empty -> page 14 */
       /* data bits AND A STOP BIT are recieved -> page 15 */
       /* 
       TRANS_RXE = 1 and RXD = "low" => start bit detected 
       if RXE is set to 0 during reception, reception completes and operation stops -> page 14
       */
       /* when reception starts -> SR_RXRUN = 1, when it ends SR_RXRXRUN = 0 which sets RXEND */
}


uint32_t fsys_mhz(void)
{
    /* CGSYSCR[HCLKSEL] 0:fsys/1, 1:fsys/2 ...  */
    /* CGPLL0SEL[PLL0SEL] 1=PLL koristi fsys */
    /* CGPLL0SEL[PLL0ON]  1=PLL uključen      */
    /* CGPLL0SEL[PLL0SET] daje množilac       */
    /* Ovde samo grubo: ako je PLL0SEL=1 pretpostavljamo 80 MHz */
    if (TSB_CG->PLL0SEL & (1<<2))   /* PLL0SEL */
        return 80;
    else
        return 40;              /* direktan kristal sa deliocem 1/1 */
}
